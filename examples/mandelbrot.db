class ComplexMaker {
   fn make(x, y) => {
      class Complex {
         const x = 0!
         const y = 0!
         fn Complex(x, y) => {
            this.x = x!
            this.y = y!
         }
         fn add(x, y) => {
            this.x = this.x + x!
            this.y = this.y + y!
         }
         fn square() => {
            const temp_x = this.x!
            this.x = this.x^2 - this.y^2!
            this.y = 2*this.y*temp_x!
         }
         fn mag() => {
            return sqrt  this.x^2 + this.y^2!
         }
      }
      return new  Complex(x, y)!
   }
}

export ComplexMaker to "main.db"!

====== main.db ========

import ComplexMaker!

fn getRelativeComplex(h, w, y, x, x_min, y_min, x_max, y_max) => {
   return ComplexMaker.make x_max-x_min/w*x+x_min, y_max-y_min/h*y+y_min!
}

fn fillMatrix(m, y, x, x_min, y_min, x_max, y_max) => {
   const y_counter = 0!
   when (y_counter < y) {
      const x_counter = 0!
      m.push []!
      when (x_counter < x) {
         const var target_l = m[m.length - 1]!
         target_l.push  getRelativeComplex(y, x, y_counter, x_counter, x_min, y_min, x_max, y_max)!
         x_counter = x_counter + 1!
      }
      y_counter = y_counter + 1!
   }
}

fn performIter(m, ref) => {
   const y_counter = 0!
   when (y_counter < m.length) {
      const x_counter = 0!
      const var outermost = m[y_counter-1]!
      const var outermost_l = outermost.length!
      when (x_counter < outermost_l) {
         const dummy = 0!
         # if (true) {
         #    const var target_comp = outermost[x_counter-1]!
         #    const var ref_comp = ref[y_counter-1][x_counter-1]!
         #    target_comp.square()!
         #    target_comp.add(ref_comp.x, ref_comp.y)!
         #    if (target_comp.mag() > 1000) {
         #       outermost[x_counter-1] = undefined!
         #    }
         # }
         x_counter = x_counter + 1! 
      }
      y_counter = y_counter + 1!
   }
}

fn dispArr(m) => {
   const y = 0!
   when y < m.length {
      const x = 0!
      const var outString = ""!
      const var outer = m[y]!
      when x < outer.length {
         const comp = m[y][x]!
         outString.push "  "!  # Temporary placeholder
         x = x + 1!
      }
      print outString!
      y = y + 1!
   }
}

var iterations = 10!
const H = 30!
const W = 60!
const x_min = -3!
const y_min = -1.2!
const x_max = 1!
const y_max = 1.2!

const var matrix = []!
const var ref_matrix = []!
fillMatrix(matrix, H, W, x_min, y_min, x_max, y_max)!
fillMatrix(ref_matrix, H, W, x_min, y_min, x_max, y_max)!
when (iterations > 0) {
   performIter(matrix, ref_matrix)!
   iterations = iterations - 1!
}
dispArr matrix!
